= Options =

== -c option ==

`-c`: If the `-c` option is present, then command are read from the *first*
non-option argument command string. If there are arguments after the command
string, the first argument is assigned to $0 and any remaining arguments are
assigned to the positional parameters. The assignment to $0 sets the name of
the shell, which is used in warning and error messages. 

-   The command below will display 123:
    {{{
        $ bash -c "echo 123"
        123
    }}}

-   *Note*: It only treat the first non-option argument as command string, so
    the following command won't display 123:
    {{{
        $ bash -c echo 123

    }}}

*Note*: By default, bash will read commands from some file. Use `-c` option
can make bash to execute command from string.


= Variables =

`PROMPT_COMMAND`: If set, the value is executed as a command prior to issuing
each primary prompt.

= Quoting =

== $'string' ==

Words of the form $'string' are treated specially. The word expands to string,
with backslash-escaped characters replaced as specified  by the ANSI C
standard. Backslash escape sequences, if present, are decoded as follows:

{{{
    \a             alert (bell)
    \b             backspace
    \e
    \E             an escape character
    \f             form feed
    \n             new line
    \r             carriage return
    \t             horizontal tab
    \v             vertical tab
    \\             backslash
    \'             single quote
    \"             double quote
    \?             question mark
    \nnn           the eight-bit character whose value is the octal value nnn (one to three digits)
    \xHH           the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
    \uHHHH         the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
    \UHHHHHHHH     the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)
    \cx            a control-x character
}}}

The expanded result is single-quoted, as if the dollar sign had not been
present. For example:

{{{
    $ echo abc$'\b'd
    abd
}}}
{{{
    $ echo 123$'\n'321
    123
    321
}}}

(Find example code in [[https://github.com/an9wer/ltips/blob/master/Bash/quoting.sh|here]])

== $"string" ==

A double-quoted string preceded by a dollar sign `$"string"` will cause the
string to be translated according to the current locale.  If the current locale
is C or POSIX, the dollar sign is ignored.  If the string is translated and
replaced, the replacement is double-quoted. For example:

{{{
    $ echo abc$"\b"d
    abc\bd
}}}
{{{
    $ echo 123$"\n"321
    123\n321
}}}

(Find example in [[https://github.com/an9wer/ltips/blob/master/Bash/quoting.sh|here]])

= Parameters =

== Special parameters ==


=== parametedr * ===

`*`: Expands to the positional paramters, starting from one. When the expansion
is `not` within double quotes, each positional parameters expands to a separate
word. In contexts where it is performed, those words are subject to further
word splitting and pathname expansion. When the expansion occurs within double
quotes, it expands to a single word with the value of each parameter separated
by the first character of the `IFS` special variable. That is, `"$*"` is
equivalent to `"$1c$2c.."`, where c is the first character of the value of the
IFS variable. If `IFS` is unset, the parameters are separated by spaces. If
`IFS` is null, the parameters are joined without intervening separators.

Let's see how `IFS` makes effect.

First create a function which displays `$*`:
{{{
    $ function func() { echo $*; }
}}}

Then:
{{{
    $ func 1 2 3
    1 2 3
}}}

Then set IFS to other value:
{{{
    $ IFS=a func 1 2 3
    1a2a3
}}}

Then unset IFS:
{{{
    $ unset IFS; func 1 2 3
    1 2 3
}}}

Also, let's check the length of `$*`:
{{{
    $ function func() { echo ${#*}; }
    $ func 1 2 3
    3
}}}

Let's see the difference between `$*` and `"$*"`.

First create a function to display the elements in `$*` and `"$*"`:
{{{
    function func() { local a=($*) b=("$*"); declare -p a b; }
}}}

Then:
{{{
    $ func 1 2 3
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1 2 3")
}}}

We can find out that `$*` expands each parameter to a separate word, but `"$*"`
expands each parameter to one word.

=== Parameter @ ===

`@`: Expands to the positional parameters, starting from one. When the
expansion occurs within double quotes, each parameter expands to a separate
word. That is, `"$@"` is equivalent to `"$1" "$2" ...`. If the double-quoted
expansion occurs within a word, the expansion of the first parameter is joined
with the beginning part of the original word, and the expansion of the last
parameter is joined with the last part of the original word. When there are no
posisional parameters, `"$@"` and `$@`  expand to nothing.

Let's see the difference between `$@` and `"$@"`.

First create a function to display the elements in `$@` and `"$@"`:
{{{
    function func() { local a=($@) b=("$@"); declare -p a b; }
}}}

Then:
{{{
    $ func 1 2 3
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1" [1]="2" [2]="3")
}}}

We can find out that `$@` and `"$@"` are same.

= Parameter =

A variable may be assigned to by a statement of the form
{{{
    name=[value]
}}}

If value is not given, the variable is assigned the null string. All values
undergo tilde expansion, parameter and variable expansion, command
substitution, arithmetic expansion, and quote removal.

In the context where an assignment statement is assigning a value to a shell
variable or array index, the += operator can be used to append to or add to the
variable's previous value. When += is applied to a variable for which the
integer attribute has been set, value is evaluated as an arithmetic expression
and added to the variable's current value, which is also evaluated. When += is
applied to an array variable using compound assignment, the variable's value is
not unset (as it is when using =), and new values are appended to the array
beginning at one greater then the array's maximum index (for indexed arrays) or
added as additional key-value pairs in an associative array. When applied to a
string-valued variable, value is expanded and appended to the variable's value.

{{{
    $ declare -i var=1+2
    $ var+=3
    $ declare -p var
    declare -i var="6"
}}}

{{{
    $ declare -a var=(1 2)
    $ var+=3
    $ declare -p var
    declare -a var=([0]="13" [1]="2")
}}}

{{{
    $ declare -a var=(1 2)
    $ var+=(3)
    $ declare -p var
    declare -a var=([0]="1" [1]="2" [2]="3")
}}}

{{{
    $ declare -- var="12"
    $ var+=3
    $ declare -p var
    declare -- var="123"
}}}

Assign multiple variables splitting by whitespace in one line:
{{{
    $ a=1 b=2 c=3
}}}

= Array =

Any element of an array may be referenced using `${name[subscript]}`. The
braces are required to avoid conflicts with pathname expansion. If subscript is
@ or *, the word expansion to all members of name. These subscripts differ only
when the word appears whin double quotes. If the word is double-quoted,
`${name[*]}` expands to a single word with the value of each array member
separated by the first character of the `IFS` special variable, and
`${name[@]}` expands each element of name to a separate word.

{{{
    $ var=(1 2 3)
    $ a=(${var[@]})
    $ b=("${var[@]}")
    $ declare -p a b
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1" [1]="2" [2]="3")
    declare -- a="1 2 3"
    declare -- b="1 2 3"
}}}

{{{
    $ var=(1 2 3)
    $ a=(${var[*]})
    $ b=("${var[*]}")
    $ declare -p a b
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1 2 3")
}}}

{{{
    $ IFS=- var=(1 2 3)
    $ a=(${var[*]})
    $ b=("${var[*]}")
    $ declare -p a b
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1-2-3")
}}}

= Parameter Expansion =

== Use default values ==

{{{
    ${parameter:-word}
}}}

If parameter is unset or null, the expansion of word is substituted. Otherwise,
the value of parameter is substituted.

{{{
    $ unset a
    $ echo ${a:-123}
    123
    $ echo ${a}

}}}


== Assign default values ==

{{{
    ${parameters:=word}
}}}

If parameter is unset or null, the expansion of word is assigned to parameter.
The value of parameter is then substituted. 

*Note*: Positional parameters and special parameters may not be assigned to in
this way.

{{{
    $ unset a
    $ echo ${a:=123}
    123
    $ echo ${a}
    123
}}}


== Substring expansion ==

{{{
    ${parameter:offset}
    ${parameter:offset:length}
}}}

It expands to the substring of the value of `parameter` starting at the
character specified by `offset` and expanding to up to `length` characters.

`offset` and `length` are arithmetic expressions. If `offset` or `length`
evaluates to a number less than zero, the value is used as an offset in
characters from the end of value of `parameter`.

*Note* that a negative `offset` must be separated from the colon by at least
one space to avoid being confused with the `:-` expansion. 

When `parameter` is a variable whose value is string:

{{{
    $ string=0123456789
    $ echo ${string:2}
    23456789
    $ echo ${string:2:4}
    2345
    $ echo ${string:2:-2}
    234567
    $ echo ${string: -4}
    6789
    $ echo ${string: -4:-2}
    67
}}}

{{{
    $ array[0]=0123456789
    $ echo ${array[0]:2}
    23456789
    $ echo ${array[0]:2:4}
    2345
    $ echo ${array[0]:2:-2}
    234567
    $ echo ${array[0]: -4}
    6789
    $ echo ${array[0]: -4:-2}
    67
}}}

When `parameter` is '@' (*Note*: it's an expansion error if `length` evaluates
to number less than zero):

{{{
    $ set -- 0 1 2 3 4 5 6 7 8 9
    $ echo ${@:2}
    23456789
    $ echo ${@:2:4}
    2345
    $ echo ${@:2:-2}
    bash: -2: substring expression < 0
    $ echo ${@: -4}
    6789
    $ echo ${@: -4:-2}
    bash: -2: substring expression < 0
}}}

When `parameter` is an indexed array name subscripted by '@' or '*' (*Note*:
it's an expansion error if `length` evaluates to number less than zero):

{{{
    $ array=(0 1 2 3 4 5 6 7 8 9)
    $ echo ${array[@]:2}
    23456789
    $ echo ${array[@]:2:4}
    2345
    $ echo ${array[@]:2:-2}
    bash: -2: substring expression < 0
    $ echo ${array[@]: -4}
    6789
    $ echo ${array[@]: -4:-2}
    bash: -2: substring expression < 0
}}}

(Find example code in [[https://github.com/an9wer/ltips/blob/master/Bash/parameter_expansion.sh|here]])

= Conditional expressions =

Conditional expressions are used by the `[[` compound command and the `test`
and `[` builtin commands to test file attributes and perform string and
arithmetic comparisons.

{{{
    string1 == string2
    string1 = string2
}}}
True if the strings are equal. `=` should be used with the `test` command for
POSIX conformance.

{{{
    string1 != string2
}}}
True if strings are not equal.

{{{
    arg1 OP arg2
}}}
`OP` is one of `-eq, -ne, -lt, -le, -gt or -ge`. These arithmetic binary
operators return true if arg1 is euqal to, not equal to, less than, less than
or equal to, greater than, or greater than or equal to arg2, respectively. Arg1
and arg2 may be positive or negative integers.

= Built-in =

== : ==

{{{
    : [arguments]
}}}

Do noting beyond expanding arguments and performing redirections. The return
status is zero.

-   Do expand arguments:
    {{{
        $ : ${a:=123}
        $ echo $a
        123
    }}}

-   Do flush file content:
    {{{
        $ :>/path/to/file
        $ cat /path/to/file

    }}}

== [[ ==

{{{
    [[ expression ]]
}}}

Return a status of 0 or 1 depending on the evaluation of the conditional
expression. Word splitting and pathname expansion are not performed on the
words between the `[[` and `]]` (*Note*: This will expand in `test` and `[`,
see [[https://stackoverflow.com/questions/669452/is-double-square-brackets-preferable-over-single-square-brackets-in-ba|this]]);
tilde expansion, parameter and varibale expansion, arithmetic expansion,
command substitution, process substitution, and quote removal are performed.

*Note*: When used with `[[`, the `<` and `>` operators sort lexicographically
using the current locale.

Expression may be combined using the following operators, listed in descreasing
order of precedence:

{{{
    ( expr )       | used to override the normal precedence of operators
    ! expr         | True if expression is false
    expr1 && expr2 | True if both expr1 and expr2 are true
    expr1 || expr2 | True if either expr1 and expr2 is true
}}}

*Note*: Operator `&&` and `||` can not be used in `test` and `[`.

-   If file `abc` is in the current directory, then `test` and `[` will expand
    it first:
    {{{
        $ [ a = a* ] && echo gotcha    # equals to: [ a = abc ] && echo gotcha
        $ 
    }}}

-   But it doesn't matter when using `[[`:
    {{{
        $ [[ a == a* ]] && echo gotcha
        $ gotcha
    }}}

== test [ ==

{{{
    test expression
    [ expression ]
}}}

Return a status of 0 or 1 depending on the evaluation of the conditional
expression. Each operator and operand must be a seperate argument.

Expression may be combined using the following operators, listed in decreasing
order of precedence:

{{{
    ! expr         | True if expr is false
    ( expr )       | Used to override the normal precedence of operators
    expr1 -a expr2 | True if both expr1 and expr2 are true
    expr1 -o expr2 | True if either expr1 or expr2 is true
}}}

*Note*: Operator `-a` and `-o` can not be used in `[[`.

== shopt ==

{{{
    shopt [-pqsu] [-o] [optname ...]
}}}

`-s`: Enable (set) each optname.

`-u`: Disable (unset) each optname.

`-q`: Supresses normal output (quiet mode); the return status indicates whether
the optname is set or unset. If multiple optname arguments are given with `-q`,
the return status is zero if all optnames are enabled; non-zero otherwise.

`-o`: Restrict optname to those defined for use with `set -o`.

If either `-s` or `-u` is used with no optname arguments, shopt shows only
those options which are set or unset, respectively. Unless otherwise noted, the
shopt options are disabled by default.

Display all options:
{{{
    shopt
}}}

Only display enabled options:
{{{
    shopt -s
}}}

Only display disabled options:
{{{
    shopt -u
}}}

Display options defined by `set -o`:
{{{
    shotp -o
}}}

`dotglob`: If set, bash includes filename beginning with a '.' in the results
of pathname expansion.

== References ==

-   [[https://www.gnu.org/software/bash/manual/bash.html|GNU bash manual]]

-   `man bash`
