= Bash Expansion

== Parameter Expansion

=== Use default values

----
    ${parameter:-word}
----

If parameter is unset or null, the expansion of word is substituted. Otherwise,
the value of parameter is substituted.

----
    $ unset a
    $ echo ${a:-123}
    123
    $ echo ${a}

----


=== Assign default values

----
    ${parameters:=word}
----

If parameter is unset or null, the expansion of word is assigned to parameter.
The value of parameter is then substituted. 

----
    $ unset a
    $ echo ${a:=123}
    123
    $ echo ${a}
    123
----

[NOTE]
Positional parameters and special parameters may not be assigned to in
this way.


=== Substring Expansion

----
    ${parameter:offset}
    ${parameter:offset:length}
----

It expands to the substring of the value of `parameter` starting at the
character specified by `offset` and expanding to up to `length` characters.

`offset` and `length` are arithmetic expressions. If `offset` or `length`
evaluates to a number less than zero, the value is used as an offset in
characters from the end of value of `parameter`.

[NOTE]
A negative `offset` must be separated from the colon by at least
one space to avoid being confused with the `:-` expansion. 

[TIP]
When `parameter` is a variable whose value is string:

----
    $ string=0123456789
    $ echo ${string:2}
    23456789
    $ echo ${string:2:4}
    2345
    $ echo ${string:2:-2}
    234567
    $ echo ${string: -4}
    6789
    $ echo ${string: -4:-2}
    67
----

----
    $ array[0]=0123456789
    $ echo ${array[0]:2}
    23456789
    $ echo ${array[0]:2:4}
    2345
    $ echo ${array[0]:2:-2}
    234567
    $ echo ${array[0]: -4}
    6789
    $ echo ${array[0]: -4:-2}
    67
----

[TIP]
When +parameter+ is `@' (*Note*: It's an expansion error if +length+ evaluates
to number less than zero):

----
    $ set -- 0 1 2 3 4 5 6 7 8 9
    $ echo ${@:2}
    23456789
    $ echo ${@:2:4}
    2345
    $ echo ${@:2:-2}
    bash: -2: substring expression < 0
    $ echo ${@: -4}
    6789
    $ echo ${@: -4:-2}
    bash: -2: substring expression < 0
----

[TIP]
When +parameter+ is an indexed array name subscripted by `@' or `\*' (*Note*:
It's an expansion error if +length+ evaluates to number less than zero):

----
    $ array=(0 1 2 3 4 5 6 7 8 9)
    $ echo ${array[@]:2}
    23456789
    $ echo ${array[@]:2:4}
    2345
    $ echo ${array[@]:2:-2}
    bash: -2: substring expression < 0
    $ echo ${array[@]: -4}
    6789
    $ echo ${array[@]: -4:-2}
    bash: -2: substring expression < 0
----

(Find example code in https://github.com/an9wer/ltips/blob/master/Bash/parameter_expansion.sh[here])

== Pathname Expansion

After word splitting, unless the `-f` option has been set, bash scans each word
for the characters `*`, `?`, and `[`. If one of these characters appears, then
the word is regarded as a pattern, and replaced with an alphabetically sorted
list of fileames matching the pattern. If no matching filnames are found, and
the shell option `nullglob` is not enabled, the word is left unchanged. If the
`nullglob` option is set, and no matches are found, the word is removed. If the
`failglob` shell option is set, and no matches are found, an error message is
printed and the command is not executed. If the shell option `nocaseglob` is
enabled, the match is performed without regard to the case of alphabetic
characters. When a pattern is used for pathname expansion, the character "."
at the start of a name or immediately following a slash must be matched
explicitly, unless the shell option `dotglob` is set. The filename "." and ".."
must always be matched explicitly, even if `dotglob` is set. In other cases,
the "." character is not treated specially. When matching a pathname, the slash
character must always be matched explicitly by a slash in the pattern. but in
other matching contexts it can be matched by a special pattern character.

The `GLOBIGNORE` shell variable may be used to restrict the set of file names
matching a pattern. If `GLOBIGNORE` is set, each matching file name that also
matched one of the patterns in `GLOBIGNORE` is removed from the list of
matches. If the `nocaseglob` option is set, the matching against the pattern in
`GLOBIGNORE` is performed without regard to case. The filenames "." and ".."
are always ignored when `GLOBIGNORE` is set and not null. However, setting
`GLOBIGNORE` to a non-null value has the effect of enabling the `dotglob` shell
option, so all other filenames beginnig with a "." will match. To get the old
behavior of ignoring filenames beginning with a ".", make ".*" one of the
patterns in `GLOBIGNORE`. the `dotglob` option is disabled when `GLOBIGNORE` is
unset. The pattern matching honors the setting of the `extglob` shell option.

=== Pattern Matching

Any character that appears in a pattern, other than the special pattern
characters described below, matches itself. The NUL character may not occor in
a pattern. A backslash escapes the following character; the escaping backslash
is discarded when matching.

The special pattern characters have the following meanings:

-   `*`: Matches any string, including the null string. When the `globstar` is
    enabled, and * is used in a pathname expansion context, two adjacent *s
    used as a single pattern will match all files and zero or more directories
    and subdirectories. If followed by a /, two adjacent *s will match only
    directories and subdirectories.
-   `?`: Matches any single character.
-   `[...]`: Matches any one of the enclosed characters. A pair of characters
    spearated by a hyphen denotes a range expression; any character that falls
    between those two characters, inclusive, using the current locale's
    collating sequence and character set, is matched. If the first character
    following the `[` is a `!` or a `^` then any character not enclosed is
    matched. The sorting order of characters in range expressions is determined
    by the current locale and the values of the of the `LC_COLLATE` or `LC_ALL`
    shell variables, if set. To obtain the traditional interpretation of range
    expressions, where [a-d] is equivalent ot [abcd], set value of the `LC_ALL`
    shell variable to C, or enable the `globasciiranges` shell option. A `-`
    may be matched by including it as the first or last character in the set. A
    `]` may be matched by including it as the first character in the set.

    ** Within `[` and `]`, character classes can be specified using the syntax
    `[:class:]`, where class is one of the following classes defined in the
    POSIX standard: alnum alpha ascii blank cntrl digit graph lower print punct
    space upper word xdigit. A character class matches any character belonging
    to that class. The word character class matches letters, digits, and the
    character _.

    ** Within `[` and `]`, an equivalence class can be specified using the syntax
    `[=c=]`, which matches all characters with the same collation weight (as
    defined by the current locale) as teh character c.

    ** Within `[` and `]`, the syntax `[.symbol.]` matches the collating symbol
    symbol.
    
If the `extglob` shell option is enabled using the `shopt` builtin, several
extended pattern matching operators are recognized. In the following
description, a pattern-list is a list of one or more patterns separated by a
`|`. Composite patterns may be formed using one or more of the following
`sub-patterns`:

`?(pattern-list)`: Matches zero or one occurence of the given patterns.

`*(pattern-list)`: Matches zero or more occurrences of the given patterns.

`+(pattern-list)`: Matches one or more occurrences of the given patterns.

`@(pattern-list)`: Matches one of the given patterns.

`!(pattern-list)`: Matches anything except one of the given patterns.

Complicated extended pattern matching against long string is slow, especially
when the patterns contain alternations and the string contain multiple matches.
Using separate matches against shorter strings, or using arrays of strings
instead of a single long string, may be faster.
